iris
iris$Species="virginica"
iris
data(iris)
iris
iris$Species=="virginica"
iris[iris$"Species"=="virginica"]
iris[iris$Species=="virginica"]
iris[iris$"Species"=="virginica",]
?colMeans
colMeans(iris[iris$"Species"=="virginica",])
colMeans(iris[iris$"Species"=="virginica",], dims=2)
iris[iris$"Species"=="virginica",1:3]
colMeans(iris[iris$"Species"=="virginica",1:3])
colMeans(iris[iris$"Species"=="virginica",1:3], dims="Sepal.Width")
colMeans(iris[iris$"Species"=="virginica",1:3], dims=2)
colMeans(iris[iris$"Species"=="virginica",1:3], dims=1)
colMeans(iris)
?apply()
apply(iris, 1, mean)
apply(iris[,1:4],mean)
apply(iris[, 1:4], 2, mean)
library(datasets)
data(mtcars)
?mtcars
mtcars
?tapply
tapply(mtcars, mtcars$mpg, mean)
tapply(mtcars, mtcars$mpg, mean, simplyfy=F)
tapply(mtcars$mpg, mtcars$cy, mean)
tapply(mtcars$mpg, mtcars$cyl, mean)
tapply(mtcars$cyl, mtcars$mpg, mean)
sapply(mtcars, cyl, mean)
split(mtcars, mtcars$cyl)
with(mtcars, tapply(mpg, cyl, mean))
tapply(mtcars$cyl, mtcars$mpg, mean)
tapply(mtcars$mpg, mtcars$cyl, mean)
with(mtcars, tapply(mpg, cyl, mean))
with(mtcars, tapply(mpg, cyl, mean))
tapply(mtcars$mpg, mtcars$cyl, mean)
tapply(mpg,cyl,mean)
with(mtcars, tapply(mpg,cyl,mean))
mtcars
tapply(mtcars$hp,mtcars$cyl,mean)
avg_hp <- tapply(mtcars$hp,mtcars$cyl,mean)
avg_hp$8-avg_hp$4
avg_hp$"8"-avg_hp$"4"
avg_hp$[3]-avg_hp[1]
avg_hp[3]-avg_hp[1]
avg_hp[3]
avg_hp[1]
avg_hp[3]-avg_hp[1]
ls()
rm(list=ls())
swirl()
swirl()
library(swirl)
swirl()
getwd()
ls()
x <- 9
ls()
list.files()
?list.files
args(list.files)
old.dir <- getwd()
dir.create(testdir)
dir.create("testdir")
setwd("testdir")
file.create(mytest.R)
file.create("mytest.R")
ls()
list.files()
file.exists("mytest.R")
file.info("mytest.R")
?file.rename()
file.rename("mytest.R","mytest2.R")
file.copy("mytest2.R","mytest3.R")
file.path("mytest3.R")
?file.path()
file.path("folder1","folder2")
?dir.create
dir.create(file.path("testdir2/testdir3"))
dir.create(file.path("testdir2","testdir3"))
dir.create(file.path("testdir2","testdir3"), recursive = T)
dir.create(file.path("testdir2","testdir3"), recursive = TRUE)
unlink("testdir2")
unlink("testdir2", recursive = TRUE)
setwd("~/GitHub//datasciencecoursera")
setwd(old.dir)
unlink("testdir", recursive = TRUE)
setwd("~/GitHub/datasciencecoursera/")
getwd
getwd()
rm(list=ls())
ls
ls()
getwd()
library(swirl)
swirl()
1:20
pi:10
15:0
15:1
?':'
seq(1,20)
seq(0,10,by=0.5)
seq(5,10,length=30)
seq(5, 10, length=30)
my_seq <- seq(5, 10, length=30)
length(my_seq)
1:length(my_seq)
seq(along.with = my_seq)
seq_along(my_seq)
rep(0, times=40)
rep(c(0,1,2), times = 10)
rep(c(0,1,2), each = 10)
rm(list=ls())
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
a <- makeVector(c(5,1,3))
a$get
a$get()
a$set(7,4,1,2)
a$set(c(7,4,1,2)
a$set(c(7,4,1,2))
a$get()
m <- matrix(c(1:4),2,2)
m
solve(m)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
cachemean(makeVector(c(1,2)))
cachemean(makeVector(c(1,2)))
cachemean(makeVector(c(1,2)))
cachemean()
cachemean(m)
m <- makeVector(c(1:2))
rm(list=ls())
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
mv <- makeVector(c(1:2))
mv
mv$get
mv$get()
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
# makeCacheMatrix function stores a list of other functions that contribute to
# caching feature
makeCacheMatrix <- function(x = matrix()) {
# "i" variable is used to store inverse of a matrix passed to makeCacheMatrix function
i <- NULL
# getMatrix sub-function simply returns a matrix passed to makeCacheMatrix function
getMatrix <- function() x
# setMatrix sub-function sets a different value for "x" (function argument)
# and nulls out "i" variable
setMatrix <- function(y) {
x <<- y
i <- NULL
}
# setInverse sub-function caches an inverse of a matrix
# // calculated outside of this function -> cacheSolve()
setInverse <- function(inverse) i <<- inverse
# getInverse sub-function returns cached "i" variable
getInverse <- function() i
list(getMatrix=getMatrix, setMatrix=setMatrix,
setInverse=setInverse, getInverse=getInverse)
}
## Write a short comment describing this function
# cacheSolve function calculates inverse of a matrix (if uncached),
# otherwise takes it from memory
cacheSolve <- function(x, ...) { # x argument is expected to be makeCacheMatrix function
if (!is.null(x$getInverse()) {
message("Value loaded from cache:")
return(x$getInverse())
}
x$setInverse(solve(x$getMatrix()))
solve(x$getMatrix())
## Return a matrix that is the inverse of 'x'
}
makeCacheMatrix <- function(x = matrix()) {
# "i" variable is used to store inverse of a matrix passed to makeCacheMatrix function
i <- NULL
# getMatrix sub-function simply returns a matrix passed to makeCacheMatrix function
getMatrix <- function() x
# setMatrix sub-function sets a different value for "x" (function argument)
# and nulls out "i" variable
setMatrix <- function(y) {
x <<- y
i <<- NULL
}
# setInverse sub-function caches an inverse of a matrix
# // calculated outside of this function -> cacheSolve()
setInverse <- function(inverse) i <<- inverse
# getInverse sub-function returns cached "i" variable
getInverse <- function() i
list(getMatrix=getMatrix, setMatrix=setMatrix,
setInverse=setInverse, getInverse=getInverse)
}
rm(list=ls())
makeCacheMatrix <- function(x = matrix()) {
# "i" variable is used to store inverse of a matrix passed to makeCacheMatrix function
i <- NULL
# getMatrix sub-function simply returns a matrix passed to makeCacheMatrix function
getMatrix <- function() x
# setMatrix sub-function sets a different value for "x" (function argument)
# and nulls out "i" variable
setMatrix <- function(y) {
x <<- y
i <<- NULL
}
# setInverse sub-function caches an inverse of a matrix
# // calculated outside of this function -> cacheSolve()
setInverse <- function(inverse) i <<- inverse
# getInverse sub-function returns cached "i" variable
getInverse <- function() i
list(getMatrix=getMatrix, setMatrix=setMatrix,
setInverse=setInverse, getInverse=getInverse)
}
m <- matrix(1:4,2,2)
m
makeCacheMatrix(m)
mcm <- makeCacheMatrix(m)
makeCacheMatrix$getMatrix()
mcm$getMatrix()
m2 <- matrix(5:8,2,2)
mcm$setMatrix(m2)
mcm$getMatrix()
mcm$getInverse()
cacheSolve <- function(x, ...) { # x argument is expected to be makeCacheMatrix function
if (!is.null(x$getInverse()) {
message("Value loaded from cache:")
return(x$getInverse())
}
x$setInverse(solve(x$getMatrix()))
solve(x$getMatrix())
## Return a matrix that is the inverse of 'x'
}
cacheSolve <- function(x, ...) {
if (!is.null(x$getInverse()) {
message("Value loaded from cache:")
return(x$getInverse())
}
x$setInverse(solve(x$getMatrix()))
solve(x$getMatrix())
## Return a matrix that is the inverse of 'x'
}
cacheSolve <- function(x, ...) {
if (!is.null(x$getInverse()) {
message("Value loaded from cache:")
return(x$getInverse())
}
else {
x$setInverse(solve(x$getMatrix()))
return(solve(x$getMatrix())        )
}
## Return a matrix that is the inverse of 'x'
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
}
cacheSolve <- function(x, ...) {
if (!is.null(x$getInverse()) {
message("Value loaded from cache:")
return(x$getInverse())
}
## Return a matrix that is the inverse of 'x'
}
cacheSolve <- function(x, ...) {
x$setInverse(solve(x$getMatrix()))
return(solve(x$getMatrix()))
}
cacheSolve <- function(x, ...) {
if (!is.null(x$getInverse())
message("Value loaded from cache:")
return(x$getInverse())
x$setInverse(solve(x$getMatrix()))
return(solve(x$getMatrix()))
}
cacheSolve <- function(x, ...) {
if (!is.null(x$getInverse())
message("Value loaded from cache:")
return(x$getInverse())
x$setInverse(solve(x$getMatrix()))
return(solve(x$getMatrix()))
}
cacheSolve <- function(x, ...) {
if (!is.null(x$getInverse()) {
message("Value loaded from cache:")
return(x$getInverse())
}
x$setInverse(solve(x$getMatrix()))
return(solve(x$getMatrix()))
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
cacheSolve <- function(x, ...) {
}
cacheSolve <- function(x, ...) {
inv <- x$getInverse()
}
cacheSolve <- function(x, ...) {
inv <- x$getInverse()
if(is.null(inv)) {
invSolved <- solve(x$getMatrix)
}
}
cacheSolve <- function(x, ...) {
inv <- x$getInverse()
if(is.null(inv)) {
invSolved <- solve(x$getMatrix())
x$setInverse(invSolved)
return(invSolved)
}
message("Value loaded from cache..")
print(inv)
}
rm(list=ls())
m1 <- matrix(1:4,2,2)
m2 <- matrix(5:8,2,2)
m1
m2
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
# makeCacheMatrix function stores a list of other functions that contribute to
# caching feature
makeCacheMatrix <- function(x = matrix()) {
# "i" variable is used to store inverse of a matrix passed to makeCacheMatrix function
i <- NULL
# getMatrix sub-function simply returns a matrix passed to makeCacheMatrix function
getMatrix <- function() x
# setMatrix sub-function sets a different value for "x" (function argument)
# and nulls out "i" variable
setMatrix <- function(y) {
x <<- y
i <<- NULL
}
# setInverse sub-function caches an inverse of a matrix
# // calculated outside of this function -> cacheSolve()
setInverse <- function(inverse) i <<- inverse
# getInverse sub-function returns cached "i" variable
getInverse <- function() i
list(getMatrix=getMatrix, setMatrix=setMatrix,
setInverse=setInverse, getInverse=getInverse)
}
## Write a short comment describing this function
# cacheSolve function calculates inverse of a matrix (if uncached),
# otherwise takes it from memory
# "x" argument is expected to be makeCacheMatrix function
cacheSolve <- function(x, ...) {
inv <- x$getInverse()
if(is.null(inv)) {
invSolved <- solve(x$getMatrix())
x$setInverse(invSolved)
return(invSolved)
}
message("Value loaded from cache..")
print(inv)
}
mCM <- makeCacheMatrix(m1)
mCM$getMatrix()
mCM$setMatrix(m2)
mCM$getMatrix()
mCM$setMatrix(m1)
mCM$getMatrix()
mCM$getInverse()
cacheSolve(mCM)
mCM$getInverse()
cacheSolve(mCM)
rm(list=ls())
m <- matrix(1:4,2,2)
m2 <- matrix(5:8,2,2)
### Combination of these function below user may calculate a given matrix's inverse.
### Functions are supposed to calculate inverse only if it has not yet calculated &
### stored in cache previously.
## makeCacheMatrix() stores 1) a matrix 2) inverse of the matrix if already
## calculated by cacheSolve(). makeCacheMatrix() is storing a list of 4 items
## that are separate functions.
# "i" variable is used to store inverse of a matrix passed to the function
# - getMatrix sub-function simply returns a matrix passed to makeCacheMatrix function
# - setMatrix sub-function sets a different value for "x" (function argument)
#   and nulls out "i" variable
# - setInverse sub-function caches an inverse of a matrix
#   / that is calculated outside of this function -> cacheSolve() /
# - getInverse sub-function simply returns cached "i" variable
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
getMatrix <- function() x
setMatrix <- function(y) {
x <<- y
i <<- NULL
}
setInverse <- function(inverse) i <<- inverse
getInverse <- function() i
list(getMatrix=getMatrix, setMatrix=setMatrix,
setInverse=setInverse, getInverse=getInverse)
}
## cacheSolve function calculates inverse of a matrix using the feature of
## memory caching if possible.
# cacheSolve() retrieves stored inverse from makeCacheMatrix and evaluate its content:
# - if it is empty (NULL) then it calculates inverse value
# - otherwise it retrieves from cache
cacheSolve <- function(x, ...) {
inv <- x$getInverse()
if(is.null(inv)) {
invSolved <- solve(x$getMatrix())
x$setInverse(invSolved)
return(invSolved)
}
message("Value loaded from cache..")
print(inv)
}
### Suggested usage // with examples:
# - Create/load a matrix and assign it to a variable. // m <- matrix(1:4,2,2)
# - Load the makeCacheMatrix() and cacheSolve() functions.
# - Assign makeCacheMatrix() to a variable with the previously created/loaded
#   matrix as function's argument. // mcm <- makeCacheMatrix(m)
# - You can check now what is stored now in cache:
#       mcm$getMatrix() will return initially created/loaded matrix.
#       mcm$getInverse() will return NULL since no inverse has been calculated yet.
# - If you want to change the cached matrix you may call mcm$setMatrix(m2) where
#   m2 represent the new matrix to be cached.
# - Calling cacheSolve(mcm) will return the inverse of cached matrix (and parallelly
#   will cache inverse value to memory).
# - You may check the cached inverse by calling mcm$getInverse() (and compare to the result
#   returned previously).
# - If you call cacheSolve(mcm) again (without changing cached matrix meanwhile),
#   cacheSolve() will return matrix's inverse from memory instead of recalculating it.
#   You are informed about this on console with a message of "Value loaded from cache...".
mcm <- makeCacheMatrix(m)
mcm$getMatrix()
mcm$getInverse()
mcm$setMatrix(m2)
mcm$getMatrix()
cacheSolve(mcm)
mcm$getInverse()
cacheSolve(mcm)
mcm$setMatrix(m)
cacheSolve(mcm)
mcm$setMatrix(m2)
mcm$getInverse()
cacheSolve(mcm)
mcm$getInverse()
rm(list=ls())
exit
quit()
